--  1
/*
Используем агрегирующую функцию COUNT() для расчета числа покупателей
Дополнительно прописал DISTINCT на случай, если в справочнике будут дублирующие значения, но результат для
COUNT() и COUNT(DISTINCT) в данном случае не отличается
*/

SELECT COUNT(distinct customer_id) AS "customers_count"
FROM customers

--  2
/*
Джоиним два необходимых справочника employees и products по ключам employee_id и product_id соответственно на "таблицу фактов" sales, после чего
создаем три поля: конкатинированное поле с именем и фамилией, число операций и сумму выручки (округляем значения до целых через FLOOR()) как произведение цены конкретного продукта на 
его количество. Группируем информацию по продавцам через GROUP BY, отображаем по убыванию выручки.
*/

SELECT
	CONCAT(e.first_name,' ', e.last_name) AS seller,
	COUNT(s.*) AS operations,
	FLOOR(SUM(p.price * s.quantity)) AS income
FROM sales s
LEFT JOIN employees e
ON e.employee_id = s.sales_person_id 
LEFT JOIN products p
ON s.product_id = p.product_id
GROUP BY seller
ORDER BY income DESC

-- 3
/*
Аналогично предыдущему запросу делаем джоины, но на этот раз делаем агрегацию по средней выручке продавца. Пишем "условие" того, что средняя выручка
конкретного продавца меньше средней выручки по всем продавцам через подзапрос в HAVING, так как "работаем" с агрегированной функцией AVG(). 
Округляем значения до целых через FLOOR(). 
*/

SELECT
	CONCAT(e.first_name,' ', e.last_name) AS seller,
	FLOOR(avg(p.price * s.quantity)) AS average_income
FROM sales s
LEFT JOIN employees e
ON e.employee_id = s.sales_person_id 
LEFT JOIN products p
ON s.product_id = p.product_id
GROUP BY seller
HAVING FLOOR(avg(p.price * s.quantity)) < (
	SELECT FLOOR(avg(p.price * s.quantity)) 
	FROM sales s 
	LEFT JOIN products p 
	ON s.product_id = p.product_id
	)
ORDER BY average_income ASC

--4
/*
Аналогично собираем таблицу из справочников и таблицы-факта, конвертируем дату в имена дней недели, группируем по имени продавца и дню недели, сортируем по тем же полям в прямом порядке.
*/

SELECT
	CONCAT(e.first_name,' ', e.last_name) AS seller,
	to_char(s.sale_date, 'day') AS day_of_week,
	FLOOR(sum(p.price * s.quantity)) AS income
FROM sales s
LEFT JOIN employees e
ON e.employee_id = s.sales_person_id 
LEFT JOIN products p
ON s.product_id = p.product_id
GROUP BY seller, day_of_week
ORDER BY seller, to_char(s.sale_date, 'day')

--5
/*
Через CASE прописываем условие для дифференциации покупателей по возрастным группам (с учетом того, что BETWEEN включает в себя оба "края"), считаем количество строк при группироке по 
возрастной группе.
*/

select case
		when age between 16 and 25 then '16-25'
		when age between 26 and 40 then '26-40'
		else '40+'
	end as age_category,
	count(*)
from customers
group by age_category

--6
/*

*/

select
	to_char(s.sale_date, 'YYYY-MM') as selling_month,
	COUNT(distinct s.customer_id) as total_customers,
	FLOOR(SUM(p.price * s.quantity)) as income
from sales s 
left join customers c 
on s.customer_id = c.customer_id
left join products p 
on s.product_id = p.product_id
group by selling_month
order by selling_month asc 
